## 第6章　コーディング段階
### 31. 偶発プログラミング
* 問題なく動作していたとしてもプログラムがなぜ動いているのかを把握すること  
→動かなくなったときもその理由がわからないため、バグ発生時に修正に時間がかかる

* 動いているように見えるだけで動いていないのかもしれない  
→常に何をやっているのかを意識すること。完全に理解しないコードは作成しない

* 偶然の状況下で動いているのかもしれない、他の状況下では動かないかもしれない  
→信頼の置けるものだけを前提とする

* ライブラリの次リリースでは動作が変更になるかもしれない  
→仮定をドキュメント化する。仮定をテストすること。

* 不要、余計な呼び出しはコード実行を遅くし、バグを混入するかもしれない  
→過去のしがらみにとらわれない。リファクタリングを欠かさない。

### 32. アルゴリズムのスピード

* O()（オーダー）記法で見積もる  
→メモリ消費の見積もりにも適用できる  
O(n*2)は同じものでも関係はわからないなどに注意する。

* コード自身が何をやっているのかも考慮する  
→nがとりうる値によってオーダーの速度が異なる

* 見積もりの後に必ず検証をすること

### 33. リファクタリング
* ｺｰﾄﾞ記述のやり直し、再構築、再設計などの総称


* ｺｰﾄﾞをリファクタリングするときの基準
 * 二重化DRY原則に反している
 * 直行していない設計
 * 知識が時代遅れ
 * パフォーマンスの改修


* リファクタリングを早めにこまめにすること  
→将来拡大した問題を修復する為に多くの時間を要することになる


* リファクタリング時の注意
 * 機能追加と同時に行ってはならない
 * テストが完了しているか確認する。頻繁にテストする
 * 各作業を局所的な小さな修正にする


### 34. テストしやすいｺｰﾄﾞ
* 契約に対してテストを行う  
→ｺｰﾄﾞが契約に合致しているのか、契約がわれわれの思っている通りになっているのかを確認する  
契約と、契約に沿ったテストを設計すること  

* ｺｰﾄﾞ実装の前にテストを作成しておけばインターフェイスのテストをしていることにもなる  
→テストｺｰﾄﾞはソースコードに近いところに置くこと。モジュール内に埋め込むことでも良い

* ログファイルを設計すること

### 35. 邪悪な魔法使い(ウィザード)
* コードなどを自動で生成してくれるもの（コードジェネーター）  
→偶発的なプログラミングにならないように、理解できないウィザードのコードは使わないこと
